<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Kotlin Compiler IR Visualizer</title>
    <script src="libs/d3/d3.v7.min.js"></script>
    <script src="libs/d3graphviz/d3-graphviz-5.6.0.min.js"></script>
    <script src="visualizer.js"></script>
    <script src="helper.js"></script>
    <script src="communication.js"></script>
    <script src="codeinspector.js"></script>
    <script src="objectinspector.js"></script>
    <link rel="stylesheet" href="visualizer.css">
    <link rel="stylesheet" href="popup.css">

    <link rel="stylesheet" href="libs/prism/prism.css"/>
    <script src="libs/prism/prism.js"></script>
</head>
<body>
<div class="container">
    <div id="top">
        <h1>Kotlin Compiler IR Visualizer</h1>
        <button id="open-filter" class="filter-button">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M15 2H1L7 9.5V14L9 15V9.5L15 2Z" stroke="currentColor" stroke-width="1.5"
                      stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            Filters
            <span id="filter-count"
                  style="background: #ddd; border-radius: 50%; width: 20px; height: 20px; display: inline-flex; justify-content: center; align-items: center; font-size: 12px;">0</span>
        </button>
        <button id="download-svg">Download SVG</button>
        <label for="enable-grouping">Enable Grouping:</label>
        <input type="checkbox" checked id="enable-grouping">
        <button id="closeVisualizer" class="last-button">Close Visualizer</button>
    </div>

    <div id="filter-popup" class="filter-popup">
        <h3>Filter Nodes</h3>
        <div class="filter-row">
            <select id="filter-type" aria-label="Filter Type">
                <option value="NodeType">Node Type</option>
                <option value="Name">Name</option>
            </select>
            <input type="text" id="filter-value" placeholder="Filter value" aria-label="Filter Value">
        </div>
        <div class="filter-buttons">
            <button id="add-filter">Add Filter</button>
        </div>
        <div class="filter-buttons">
            <button id="apply-filter">Apply</button>
        </div>
        <div class="active-filters">
            <div class="horizontal spacebetween">
                <h4>Active Filters</h4>
                <button id="clear-filters">Clear All</button>
            </div>
            <div id="active-filter-tags"></div>
        </div>
    </div>

    <div class="content-wrapper">
        <code-inspector id="inspector" class="column"></code-inspector>
        <div class="separator"></div>
        <div id="graph-container" class="graph-container no-select column"></div>
        <div class="separator"></div>
        <div id="leftCol" class="spacebetween vertical column">
            <div id="selected-node-info">
                <h3>Click on any node to see details here</h3>
            </div>
            <button disabled="disabled" id="expandAllChildren">Expand All Children</button>
        </div>
    </div>
</div>

<object-inspector id="object-inspector"></object-inspector>

<div id="fullscreen-popup">
    <div class="popup-box">
        <button class="close-btn" aria-label="Close">Ã—</button>
        <h1 id="codeHeading"></h1>
        <pre id="codeParagraph" class="code-block"></pre>
    </div>
</div>

<script>
    const checkbox = document.getElementById('enable-grouping');
    const expandBtn = document.getElementById('expandAllChildren');


    const jsonString = getJSON();
    let obj = JSON.parse(jsonString);
    obj = groupArrays(obj);
    restructureTree(obj);
    let nodeDict = createNodeDict(obj);
    let dotSource = createDotSource(obj);


    let graphvizInstance;
    let selectedNodeId;
    let autoZoomToNode = false

    const activeFilters = [];

    function initGraphviz() {
        const container = document.getElementById("graph-container");
        graphvizInstance = d3.select(container)
            .graphviz({useWorker: false})
            .width("100%")
            .height("100%")
            .fit(true)
            .zoom(true)
            .zoomScaleExtent([1, Infinity]);

        renderGraph(dotSource);
    }

    function renderGraph(dotSource) {
        try {
            const container = document.getElementById("graph-container");

            graphvizInstance
                .transition(function () {
                    return d3.transition()
                        .duration(750)
                        .ease(d3.easeLinear);
                })
                .renderDot(dotSource)
                .on("end", function () {
                    const svg = container.querySelector("svg");
                    svg.dataset.originalViewBox = svg.getAttribute("viewBox");

                    addNodeClickHandlers(svg);

                    setUpDownloadButton(svg);

                    if (getNodeByNodeId(selectedNodeId)) {
                        markSelected(selectedNodeId);
                        let selectedNodeGroup = getNodeByNodeId(selectedNodeId);
                        drawAllDottedLines(selectedNodeGroup)
                    } else {
                        clearSelection();
                        graphvizInstance.resetZoom();
                    }

                    d3.select(container).select("svg").on("dblclick.zoom", null);

                    if (autoZoomToNode) {
                        zoomToNode(selectedNodeId);
                        autoZoomToNode = false;
                    }
                });
        } catch (error) {
            console.error(error);
            document.getElementById("graph-container").innerHTML =
                `<div style="color: red; padding: 20px;">
                Error rendering graph: ${error.message}
            </div>`;
        }
    }

    function updateGraph() {
        dotSource = createDotSource(obj);
        try {
            if (!graphvizInstance) {
                console.error("Graphviz instance not initialized. Call initGraphviz() first.");
                return;
            }


            removeAllDottedLines()

            graphvizInstance
                .transition(function () {
                    return d3.transition()
                        .duration(750)
                        .ease(d3.easeLinear);
                })
                .tweenShapes(true)
                .tweenPaths(false)
                .renderDot(dotSource);

        } catch (error) {
            console.error("Error updating graph:", error);
            document.getElementById("graph-container").innerHTML =
                `<div style="color: red; padding: 20px;">
                Error updating graph: ${error.message}
            </div>`;
        }
    }


    function addNodeClickHandlers(svg) {
        const nodeGroups = svg.querySelectorAll(".node");
        nodeGroups.forEach(nodeGroup => {
            nodeGroup.style.cursor = "pointer";
            if (!nodeGroup.handlersAdded) {

                nodeGroup.addEventListener("mouseover", function () {
                    const shape = nodeGroup.querySelector("ellipse, polygon, path, rect");
                    if (shape) {
                        shape.setAttribute("stroke-width",
                            parseFloat(shape.getAttribute("stroke-width") || 1) + 1);
                    }
                });

                nodeGroup.addEventListener("mouseout", function () {
                    const shape = nodeGroup.querySelector("ellipse, polygon, path, rect");
                    if (shape) {
                        shape.setAttribute("stroke-width",
                            Math.max(1, parseFloat(shape.getAttribute("stroke-width") || 2) - 1));
                    }
                });

                nodeGroup.addEventListener("dblclick", function () {
                    const nodeId = nodeGroup.querySelector("title").textContent.trim();
                    const nodeData = nodeDict[nodeId];
                    setChildVisibility(nodeData, hasInvisibleChild(nodeData))

                    updateGraph()
                });

                nodeGroup.addEventListener("click", function () {
                    expandBtn.disabled = false;

                    const nodeId = nodeGroup.querySelector("title").textContent.trim();

                    setInfoDiv(nodeId);
                    setCodeInspector(nodeId);

                    unmarkSelected();
                    selectedNodeId = nodeId;
                    markSelected(selectedNodeId);

                    removeAllDottedLines();
                    drawAllDottedLines(nodeGroup);
                });
                nodeGroup.handlersAdded = true;
            }

        });
    }

    function clearSelection() {
        if (selectedNodeId) {
            unmarkSelected();
            selectedNodeId = null;
        }
        setInfoDiv(null);
        setCodeInspector(null);
    }


    checkbox.addEventListener('change', function () {
        const jsonString = getJSON();
        obj = JSON.parse(jsonString);
        if (checkbox.checked) {
            obj = groupArrays(obj);
        }
        restructureTree(obj);
        nodeDict = createNodeDict(obj);
        dotSource = createDotSource(obj);
        clearSelection();
        updateGraph();
    });

    expandBtn.addEventListener('click', function () {
        expandAll(nodeDict[selectedNodeId]);
        updateGraph();
    });

    const filterButton = document.getElementById('open-filter');
    const filterPopup = document.getElementById('filter-popup');
    const addFilterBtn = document.getElementById('add-filter');
    const applyFilterBtn = document.getElementById('apply-filter');
    const clearFiltersBtn = document.getElementById('clear-filters');
    const filterType = document.getElementById('filter-type');
    const filterValue = document.getElementById('filter-value');
    const activeFilterTags = document.getElementById('active-filter-tags');
    const filterCount = document.getElementById('filter-count');

    filterButton.addEventListener('click', function () {
        if (filterPopup.style.display === 'block') {
            filterPopup.style.display = 'none';
        } else {
            filterPopup.style.display = 'block';
            const rect = filterButton.getBoundingClientRect();
            filterPopup.style.top = `${rect.bottom + 5}px`;
            filterPopup.style.left = `${rect.left}px`;
            filterValue.focus();
        }
    });

    document.addEventListener('click', function (event) {
        if (!filterPopup.contains(event.target) && event.target !== filterButton && event.target.className !== "filter-tag-close") {
            filterPopup.style.display = 'none';
        }
    });

    addFilterBtn.addEventListener('click', function () {
        if (filterValue.value.trim() === '') return;

        const filter = {
            type: filterType.value,
            value: filterValue.value.trim()
        };

        const existingFilter = activeFilters.find(f =>
            f.type === filter.type && f.value === filter.value
        );

        if (!existingFilter) {
            activeFilters.push(filter);
            filterTree(obj, activeFilters)
            updateFilterTags();
            filterValue.value = '';
        }
    });

    applyFilterBtn.addEventListener('click', function () {
        updateFilterCount();
        updateGraph();
    });

    filterValue.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            addFilterBtn.click();
        }
    });

    clearFiltersBtn.addEventListener('click', function () {
        activeFilters.length = 0;
        filterTree(obj, activeFilters)
        updateFilterTags();
        updateFilterCount();
        updateGraph();
    });

    const popup = document.getElementById('fullscreen-popup');
    const closeBtn = popup.querySelector('.close-btn');

    closeBtn.addEventListener('click', () => {
        popup.classList.remove('active');
    });

    popup.addEventListener('click', (e) => {
        if (e.target === popup) {
            popup.classList.remove('active');
        }
    });

    function updateFilterTags() {
        activeFilterTags.innerHTML = '';
        activeFilters.forEach((filter, index) => {
            const tag = document.createElement('span');
            tag.className = 'filter-tag';
            tag.innerHTML = `
                ${filter.type}: ${filter.value}
                <span class="filter-tag-close" data-index="${index}">Ã—</span>
            `;
            activeFilterTags.appendChild(tag);
        });

        document.querySelectorAll('.filter-tag-close').forEach(button => {
            button.addEventListener('click', function () {
                const index = parseInt(this.dataset.index);
                activeFilters.splice(index, 1);
                filterTree(obj, activeFilters)
                updateFilterTags();
            });
        });
    }

    function updateFilterCount() {
        filterCount.textContent = String(activeFilters.length);
    }

    const inspector = document.getElementById('inspector');
    inspector.addEventListener('unitSelected', e => {
        console.log('User clicked unit:', e.detail);
        selectedNodeId = e.detail.nodeID;
        expandAllParents(nodeDict[e.detail.nodeID]);
        autoZoomToNode = true;
        updateGraph();
        setInfoDiv(selectedNodeId);
    });

    const closeVisualizerBtn = document.getElementById('closeVisualizer');

    closeVisualizerBtn.addEventListener('click', () => {
        closeVisualizer();
    });

    initGraphviz();
    setupWidthDragging();

</script>
</body>
</html>
