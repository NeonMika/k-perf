<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Kotlin Compiler IR Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-graphviz/5.0.2/d3-graphviz.min.js"></script>
    <script src="visualizer.js"></script>
    <script src="helper.js"></script>
    <link rel="stylesheet" href="visualizer.css">
</head>
<body>
<div class="container">
    <div id="top">
        <h1>Kotlin Compiler IR Visualization</h1>
        <label for="filter-word">Filter:</label>
        <input type="text" id="filter-word"></input>
        <button id="download-svg">Download SVG</button>
    </div>
    <div class="content-wrapper">
        <div id="graph-container" class="graph-container no-select"></div>
        <div id="selected-node-info">
            <h3>Click on any node to see details here</h3>
        </div>
    </div>
</div>

<script>
    const jsonString = getJSON();
    const obj = JSON.parse(jsonString);
    assignNodeIds(obj);
    const nodeDict = createNodeDict(obj);
    let dotSource = createDotSource(obj);


    // Global variable to store the graphviz instance
    let graphvizInstance;
    let selectedNodeId;

    // Initialize the graphviz instance (call this once during setup)
    function initGraphviz() {
        const container = document.getElementById("graph-container");
        graphvizInstance = d3.select(container)
            .graphviz({useWorker: false})
            .width("100%")
            .height("100%")
            .fit(true)
            .zoom(true);

        // Initial rendering
        renderGraph(dotSource);
    }

    // Render graph initially
    function renderGraph(dotSource) {
        try {
            const container = document.getElementById("graph-container");

            // Render with graphviz
            graphvizInstance
                .transition(function () {
                    return d3.transition()
                        .duration(750)
                        .ease(d3.easeLinear);
                })
                .renderDot(dotSource)
                .on("end", function () {
                    // After rendering is complete
                    const svg = container.querySelector("svg");
                    svg.dataset.originalViewBox = svg.getAttribute("viewBox");

                    svg.addEventListener("contextmenu", function (event) {
                        //event.preventDefault();
                    });

                    addNodeClickHandlers(svg);

                    setUpDownloadButton(svg);

                    if (selectedNodeId) {
                        markSelected(svg, selectedNodeId);
                        selectedNodeGroup = getNodeByNodeId(selectedNodeId);
                        drawAllDottedLines(selectedNodeGroup)
                    }

                    d3.select(container).select("svg").on("dblclick.zoom", null);
                });
        } catch (error) {
            console.error(error);
            document.getElementById("graph-container").innerHTML =
                `<div style="color: red; padding: 20px;">
                Error rendering graph: ${error.message}
            </div>`;
        }
    }

    // Update the graph with a new dot source and animate the transition
    function updateGraph() {
        dotSource = createDotSource(obj);
        try {
            if (!graphvizInstance) {
                console.error("Graphviz instance not initialized. Call initGraphviz() first.");
                return;
            }


            removeAllDottedLines()

            // Configure the transition
            graphvizInstance
                .transition(function () {
                    return d3.transition()
                        .duration(750)  // Duration of transition in milliseconds
                        .ease(d3.easeLinear);
                })
                .tweenShapes(true)      // Enable shape tweening
                .tweenPaths(true)       // Enable path tweening
                .convertEqualSidedPolygons(true)  // Helps with smoother transitions
                .growEnteringEdges(true)  // Animate new edges growing
                .renderDot(dotSource);

        } catch (error) {
            console.error("Error updating graph:", error);
            document.getElementById("graph-container").innerHTML =
                `<div style="color: red; padding: 20px;">
                Error updating graph: ${error.message}
            </div>`;
        }
    }

    // Helper function to set up the download button
    function setUpDownloadButton(svg) {
        document.getElementById("download-svg").addEventListener("click", function () {
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "dot_graph.svg";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    }

    function addNodeClickHandlers(svg) {
        const nodeGroups = svg.querySelectorAll(".node");
        nodeGroups.forEach(nodeGroup => {
            nodeGroup.style.cursor = "pointer";
            if (!nodeGroup.handlersAdded) {

                nodeGroup.addEventListener("mouseover", function () {
                    const shape = nodeGroup.querySelector("ellipse, polygon, path, rect");
                    if (shape) {
                        shape.setAttribute("stroke-width",
                            parseFloat(shape.getAttribute("stroke-width") || 1) + 1);
                    }
                });

                nodeGroup.addEventListener("mouseout", function () {
                    const shape = nodeGroup.querySelector("ellipse, polygon, path, rect");
                    if (shape) {
                        shape.setAttribute("stroke-width",
                            Math.max(1, parseFloat(shape.getAttribute("stroke-width") || 2) - 1));
                    }
                });

                nodeGroup.addEventListener("dblclick", function () {
                    const nodeId = nodeGroup.querySelector("title").textContent.trim();
                    const nodeData = nodeDict[nodeId];
                    toggleChildren(nodeData.original, hasInvisibleChild(nodeData.original))
                    updateGraph()
                });

                nodeGroup.addEventListener("click", function () {
                    const nodeId = nodeGroup.querySelector("title").textContent.trim();

                    setInfoDiv(nodeGroup)

                    unmarkSelected(svg);
                    selectedNodeId = nodeId;
                    markSelected(svg, selectedNodeId);

                    removeAllDottedLines()
                    drawAllDottedLines(nodeGroup)
                });
                nodeGroup.handlersAdded = true;
            }

        });

    }

    const input = document.getElementById('filter-word');

    input.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            filterTree(obj, "NodeType", input.value)
            updateGraph()
        }
    });

    initGraphviz();
    //window.addEventListener("load", initGraphviz);
</script>
</body>
</html>
